<#
    .SYNOPSIS

    Short description

    Remove any comment section not used, e.g., LINK, INPUTS, or OUTPUTS
    Additonal information on comment based help: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_comment_based_help
    
    .DESCRIPTION

    Long description

    THIS CODE IS MADE AVAILABLE AS IS, WITHOUT WARRANTY OF ANY KIND. THE ENTIRE RISK
    OF THE USE OR THE RESULTS FROM THE USE OF THIS CODE REMAINS WITH THE USER.

    .NOTES 

    Requirements 

    - Windows Server 2019+
  
    Revision History 
    -------------------------------------------------------------------------------- 
    1.0 Initial release 
    1.1 xxxx

    .LINK

    https://somelink1.com/withmoreinformation

    .LINK

    https://somelink2.com/withmoreinformation

    .PARAMETER ExportFileWithoutDefaultValue

    Madatory export file name

    .PARAMETER ExportFileWithDefaultValue

    Export file name example using a default value of 'ExportFile.csv''

    .EXAMPLE

    Get-SomeCmdlet.ps1 -SomeParameter1 'ExportToUTF8.csv'

    Executes the script and exports the gathered information to a CSV file named ExportToUTF8.csv

#>

# Parameter section with examples
# Additional information parameters: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_functions_advanced_parameters
[CmdletBinding()]
param(
    [switch]ConfigureUnfiedGroupsOnPremises    
)

#region Initialize Script 

# Measure script running time
$StopWatch = [System.Diagnostics.Stopwatch]::StartNew()

$script:ScriptPath = Split-Path $script:MyInvocation.MyCommand.Path
$script:ScriptName = $MyInvocation.MyCommand.Name

# Load required module for logging
if($null -ne (Get-Module -Name GlobalFunctions -ListAvailable).Version) {
    Import-Module -Name GlobalFunctions
}
else {
    Write-Warning -Message 'Unable to load GlobalFunctions PowerShell module.'
    Write-Warning -Message 'Open an administrative PowerShell session and run Import-Module GlobalFunctions'
    Write-Warning -Message 'Please check http://bit.ly/GlobalFunctions for further instructions'
    exit
}

# Create a logging oobject
$logger = New-Logger -ScriptRoot $script:ScriptPath -ScriptName $script:ScriptName -LogFileRetention 14
$logger.Purge()
$logger.Write('Script started')

#endregion

#region Functions

function LoadScriptSettings {
    if (Test-Path -Path ('{0}\Settings.xml' -f $script:ScriptPath)) {
        # Load Script settings
        [xml]$Config = Get-Content -Path ('{0}\Settings.xml' -f $script:ScriptPath)

        Write-Verbose -Message 'Loading script settings'

        # Group settings
        $unifiedGroupsOU = $Config.Settings.GroupSettings.OU
        
        Write-Verbose -Message 'Script settings loaded'
    }
    else { 
        Write-Error -Message 'Script settings file settings.xml missing. Please check documentation.'
        exit 99
    }
}

function Request-Choice {
    [CmdletBinding()]
    param(
        [Parameter(
            Mandatory=$true,
            HelpMessage = "Provide a caption for the Y/N question.")]
        [string]$Caption
    )
    $choices =  [System.Management.Automation.Host.ChoiceDescription[]]@('&Yes','&No')
    [int]$defaultChoice = 1

    $choiceReturn = $Host.UI.PromptForChoice($Caption, '', $choices, $defaultChoice)

    return $choiceReturn   
}

#endregion

#region MAIN

LoadScriptSettings

# 1. Unfied Groups in EXO

if (Get-Command Get-ExO365Recipient -ErrorAction SilentlyContinue) {
    Write-Host "ExO already loaded!"
}
else {
    $MigCert = Get-ChildItem -Path "Cert:\CurrentUser\My" | Where-Object {$_.Subject -like "CN=CERTNAME*" } # | fl # | Format-Table Subject, FriendlyName, Thumbprint -AutoSize
    # VARS for connect
    $AppId = "GUID"
    $CertificateThumbprint = $MigCert.Thumbprint
    $Organization = "varunagroup.onmicrosoft.com"
    Connect-ExchangeOnline -AppId $AppId -CertificateThumbprint $CertificateThumbprint -Organization $Organization -Prefix ExO365
    
}

Write-Host 'Fetching Unified Groups w/ HiddenFromAddressListsEnabled = FALSE'

$unifiedGroups = Get-ExO365UnifiedGroup
$visibleUnifiedGroups = $unifiedGroups | ?{$_.HiddenFromAddressListsEnabled -eq $false}

if( ($visibleUnifiedGroups | Measure-Object).Count -gt 0) {
    $txt = ('Updating {0}/{1} unified group(s) to HiddenFromAddressListsEnabled=TRUE' -f ($visibleUnifiedGroups | Measure-Object).Count, ($unifiedGroups | Measure-Object).Count)

    Write-Host $txt
    $logger.Write($txt)

    foreach($unifiedGroup in $visibleUnifiedGroups) {
        Set-ExO365UnifiedGroup -Identity $unifiedGroup.Identity -HiddenFromAddressListsEnabled:$true
        $logger.Write( ('Group "{0}" configured' -f $unifiedGroup.DisplayName) )
    }
}
else {
    $txt = ('{0} unified groups found. All groups have HiddenFromAddressListsEnabled=TRUE' -f ($unifiedGroups | Measure-Object).Count)

    Write-Host $txt
    $logger.Write($txt)
}

# 2. Configure syncornized Unfied Groups in AD

if($ConfigureUnfiedGroupsOnPremises) {
    if($null -ne $unifiedGroupsOU) {
        # fetch all objects from OU
        $synchedGroups = Get-ADObject -SearchBase $unifiedGroupsOU -Filter {(msExchHideFromAddressLists -notlike '*') -and (ObjectClass -eq 'group')} -Properties msExchHideFromAddressLists,DistinguishedName
        $logger.Write( ('Found {0} synchronized groups' -f ($synchedGroups | Measure-Object).Count ) )

        foreach($group in $synchedGroups) {

            if($group.msExchHideFromAddressLists ne $true) {
                $logger.Write( ('Setting msExchHideFromAddressLists for [{0}]' -f $group.DisplayName))
                Set-ADObject -Identity $group.DistinguishedName -Replace @{msExchHideFromAddressLists = 'TRUE'}
            }
        }

    }
    else {
        $txt = 'No OU for synched Unified Groups specified'

        Write-Host $txt
        $logger.Write($txt)
    }
}

#endregion

#region End Script

# Stop watch
$StopWatch.Stop()

# Write script runtime
Write-Verbose -Message ('It took {0:00}:{1:00}:{2:00} to run the script.' -f $StopWatch.Elapsed.Hours, $StopWatch.Elapsed.Minutes, $StopWatch.Elapsed.Seconds)
$logger.Write( ('It took {0:00}:{1:00}:{2:00} to run the script.' -f $StopWatch.Elapsed.Hours, $StopWatch.Elapsed.Minutes, $StopWatch.Elapsed.Seconds) )
$logger.Write('Script finished')

return 0

#endregion